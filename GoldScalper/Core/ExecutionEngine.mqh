//+------------------------------------------------------------------+
//| Core/ExecutionEngine.mqh                                         |
//| ExecutionEngine - partial fills tracking, retries, reconciliation|
//+------------------------------------------------------------------+
#ifndef EXECUTION_ENGINE_MQH
#define EXECUTION_ENGINE_MQH
#property strict

#include <Trade\Trade.mqh>
#include <Crypt.mqh>            // for CryptEncode (SHA256)
#include <Math.mqh>

#include "Core/StateManager.mqh"
#include "Core/SpreadMonitor.mqh"
#include "Core/RiskManager.mqh"
#include "Core/ExponentialBackoff.mqh"
#include "Core/SessionManager.mqh"
#include "Core/ImmutableCore.mqh"
#include "Monitoring/Monitoring.mqh"
#include "Monitoring/HealthMonitor.mqh"

// NOTE: This file expects globals:
//   g_state_manager (StateManager), g_trace (TraceAlert/TraceLogger), g_spread_monitor, g_risk_manager, g_session_manager

// -------------------- Enums / Structs -------------------------------
enum ReqStatus { REQ_PENDING = 0, REQ_FILLED = 1, REQ_CANCELED = 2, REQ_OVERFILLED = 3 };
enum TradeSide { SIDE_UNKNOWN = 0, SIDE_BUY = 1, SIDE_SELL = 2 };

struct TradeRequest
{
   ulong    request_id;   // unique id generated by engine (client id)
   ulong    ticket;       // broker order id used for correlation
   string   symbol;
   double   requested;    // requested volume (lots)
   double   filled;       // cumulative filled
   datetime ts;           // request timestamp
   int      retries;      // retries count
   int      status;       // ReqStatus
   TradeSide side;        // BUY / SELL
   string   run_id;       // EA run id for traceability
   string   trace_hash;   // SHA256 hash of canonical record
};

// Minimal TradingSignal
struct TradingSignal
{
   bool   valid;
   bool   is_long;
   double entry_price;
   double stop_loss;
   double take_profit;
   double confidence;
};

// Execution result returned to caller
struct ExecutionResult
{
   bool   success;
   ulong  ticket;
   string error_msg;
   double lot_size;
   ulong  request_id;    // engine-generated id for correlation
   ExecutionResult() { success=false; ticket=0; error_msg=""; lot_size=0.0; request_id=0; }
};

// -------------------- ExecutionEngine class ------------------------
class ExecutionEngine
{
private:
   CTrade             m_trade;
   ExponentialBackoff m_backoff;
   int                m_max_retries;
   datetime           m_breaker_end;
   uint               m_magic;
   int                m_deviation;

   TradeRequest       m_requests[]; // in-memory pending requests (persisted to CSV via StateManager)

   int                m_pending_timeout_seconds;
   string             m_run_id;

public:
   ExecutionEngine()
   {
      m_magic = 123456;
      m_deviation = 10;
      m_trade.SetExpertMagicNumber((long)m_magic);
      m_trade.SetDeviation(m_deviation);
      m_backoff.Init(100, 2.0, 5000);
      m_max_retries = 3;
      m_breaker_end = 0;
      m_pending_timeout_seconds = 30;
      m_run_id = GenerateRunId();
   }

   void Init(int max_retries = 3, uint magic = 123456, int deviation = 10)
   {
      m_max_retries = max_retries;
      m_magic = magic;
      m_deviation = deviation;
      m_trade.SetExpertMagicNumber((long)m_magic);
      m_trade.SetDeviation(m_deviation);
      LoadPendingRequestsFromState();
      g_trace.Log(TRACE_INFO, "EXEC", "ExecutionEngine initialized run_id=" + m_run_id);
   }

   // -------------------------
   // Helpers: run_id and SHA256 helper
   string GenerateRunId()
   {
      // Use Time + Rand for per-process run id
      ulong id = ((ulong)TimeCurrent() << 16) ^ (ulong)(MathRand() & 0xFFFF);
      return (string)IntegerToString((long)id);
   }

   string ComputeSha256Hex(const string s)
   {
      #ifdef __MQL5__
         uchar in_bytes[]; int in_len = StringToCharArray(s, in_bytes);
         if(in_len <= 0) return "";
         uchar hash[]; ArrayResize(hash, 32);
         bool ok = CryptEncode(CRYPT_HASH_SHA256, in_bytes, hash);
         if(!ok) return "";
         string hex = "";
         for(int i=0;i<ArraySize(hash);i++) hex += StringFormat("%02X", hash[i]);
         return hex;
      #else
         return ""; // not available
      #endif
   }

   // -------------------------
   // Serialization / persistence (CSV lines) with side, run_id, trace_hash
   string SerializeRequest(const TradeRequest &r)
   {
      // Format: request_id,ticket,symbol,side,requested,filled,ts,retries,status,run_id,trace_hash
      string side_s = (r.side == SIDE_BUY) ? "BUY" : ((r.side == SIDE_SELL) ? "SELL" : "UNK");
      return StringFormat("%llu,%llu,%s,%s,%.10f,%.10f,%d,%d,%d,%s,%s",
                         (ulong)r.request_id, (ulong)r.ticket,
                         r.symbol, side_s, r.requested, r.filled,
                         (int)r.ts, r.retries, r.status,
                         r.run_id, r.trace_hash);
   }

   bool DeserializeRequest(const string line, TradeRequest &out)
   {
      string parts[]; int n = StringSplit(line, ',', parts);
      if(n < 11) return false;
      out.request_id = (ulong)StringToInteger(parts[0]);
      out.ticket     = (ulong)StringToInteger(parts[1]);
      out.symbol     = parts[2];
      string side_s  = parts[3];
      out.requested  = StringToDouble(parts[4]);
      out.filled     = StringToDouble(parts[5]);
      out.ts         = (datetime)StringToInteger(parts[6]);
      out.retries    = (int)StringToInteger(parts[7]);
      out.status     = (int)StringToInteger(parts[8]);
      out.run_id     = parts[9];
      out.trace_hash = parts[10];
      out.side = SIDE_UNKNOWN;
      if(StringCompare(side_s, "BUY") == 0) out.side = SIDE_BUY;
      else if(StringCompare(side_s, "SELL") == 0) out.side = SIDE_SELL;
      return true;
   }

   // Atomic write helper (best-effort): write to tmp then overwrite final
   bool AtomicWriteCsv(const string filename, string &lines[], int count)
   {
      string tmp = filename + ".tmp";
      int h = FileOpen(tmp, FILE_WRITE | FILE_COMMON | FILE_ANSI);
      if(h == INVALID_HANDLE) { g_trace.Log(TRACE_ERROR, "EXEC", "AtomicWriteCsv: open tmp failed " + tmp); return false; }
      for(int i=0;i<count;i++) FileWriteString(h, lines[i] + "\n");
      FileClose(h);

      // overwrite destination (best effort): delete existing then rename by copying contents
      // MQL5 lacks a reliable atomic rename across all builds; do conservative copy
      int hdest = FileOpen(filename, FILE_WRITE | FILE_COMMON | FILE_ANSI);
      if(hdest == INVALID_HANDLE)
      {
         // try creating
         hdest = FileOpen(filename, FILE_WRITE | FILE_COMMON | FILE_ANSI);
         if(hdest == INVALID_HANDLE) { g_trace.Log(TRACE_ERROR, "EXEC", "AtomicWriteCsv: open dest failed " + filename); FileDelete(tmp); return false; }
      }
      // read tmp and write to dest
      int htmp = FileOpen(tmp, FILE_READ | FILE_COMMON | FILE_ANSI);
      if(htmp == INVALID_HANDLE) { FileClose(hdest); FileDelete(tmp); g_trace.Log(TRACE_ERROR, "EXEC", "AtomicWriteCsv: reopen tmp failed"); return false; }
      // read whole tmp
      string content = "";
      while(!FileIsEnding(htmp)) content += FileReadString(htmp);
      FileClose(htmp);
      FileWriteString(hdest, content);
      FileClose(hdest);

      // remove tmp
      FileDelete(tmp);
      return true;
   }

   void SavePendingRequestsToState()
   {
      string lines[]; int cnt = ArraySize(m_requests);
      ArrayResize(lines, cnt);
      for(int i=0;i<cnt;i++) lines[i] = SerializeRequest(m_requests[i]);

      string filename = "pending_requests.csv";
      if(!AtomicWriteCsv(filename, lines, cnt))
      {
         g_trace.Log(TRACE_WARNING, "EXEC", "SavePendingRequestsToState: AtomicWriteCsv failed");
         return;
      }

      // Persist global state JSON as defense-in-depth
      if(!g_state_manager.Save())
         g_trace.Log(TRACE_WARNING, "EXEC", "SavePendingRequestsToState: g_state_manager.Save() failed");
      else
         g_trace.Log(TRACE_DEBUG, "EXEC", StringFormat("Saved %d pending requests (run=%s)", cnt, m_run_id));
   }

   void LoadPendingRequestsFromState()
   {
      string lines[]; int cnt = 0;
      if(!g_state_manager.LoadPendingCSV(lines, cnt))
      {
         g_trace.Log(TRACE_DEBUG, "EXEC", "LoadPendingRequestsFromState: LoadPendingCSV absent/failed");
         return;
      }
      ArrayResize(m_requests, 0);
      for(int i=0;i<cnt;i++)
      {
         TradeRequest r; ZeroMemory(r);
         if(DeserializeRequest(lines[i], r))
         {
            ArrayResize(m_requests, ArraySize(m_requests)+1);
            m_requests[ArraySize(m_requests)-1] = r;
         }
      }
      g_trace.Log(TRACE_INFO, "EXEC", StringFormat("Loaded %d pending requests from state (run=%s)", ArraySize(m_requests), m_run_id));
   }

   // -------------------------
   // Pending request helpers
   ulong GenerateRequestId()
   {
      ulong id = ((ulong)TimeCurrent() * 1000ULL) + (ulong)ArraySize(m_requests) + (ulong)(MathRand() & 0xFFFF);
      if(id == 0) id = (ulong)TimeCurrent();
      return id;
   }

   ulong AddPendingRequest(const ulong ticket, const string symbol, const double requested_volume, TradeSide side)
   {
      TradeRequest r; ZeroMemory(r);
      r.request_id = GenerateRequestId();
      r.ticket = ticket;
      r.symbol = symbol;
      r.requested = requested_volume;
      r.filled = 0.0;
      r.ts = TimeCurrent();
      r.retries = 0;
      r.status = REQ_PENDING;
      r.side = side;
      r.run_id = m_run_id;

      // canonical trace string for hashing
      string canon = StringFormat("%llu|%llu|%s|%d|%.10f|%d", (ulong)r.request_id, (ulong)r.ticket, r.symbol, (int)r.side, r.requested, (int)r.ts);
      r.trace_hash = ComputeSha256Hex(canon);

      ArrayResize(m_requests, ArraySize(m_requests) + 1);
      m_requests[ArraySize(m_requests)-1] = r;
      SavePendingRequestsToState();

      g_trace.Log(TRACE_INFO, "EXEC", StringFormat("Added pending request id=%llu ticket=%llu vol=%.4f side=%d run=%s hash=%s",
                    r.request_id, r.ticket, r.requested, (int)r.side, r.run_id, r.trace_hash));
      return r.request_id;
   }

   int FindRequestIndexByTicket(const ulong ticket)
   {
      for(int i=0;i<ArraySize(m_requests);i++)
         if(m_requests[i].ticket == ticket) return i;
      return -1;
   }

   bool RemoveRequestByIndex(int idx)
   {
      if(idx < 0 || idx >= ArraySize(m_requests)) return false;
      int last = ArraySize(m_requests) - 1;
      for(int i=idx;i<last;i++) m_requests[i] = m_requests[i+1];
      ArrayResize(m_requests, last);
      SavePendingRequestsToState();
      return true;
   }

   // -------------------------
   // Handle incoming DEAL events: update filled, retry partials, reconcile overfills
   void HandleTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result)
   {
      if(trans.type != TRADE_TRANSACTION_DEAL_ADD && trans.type != TRADE_TRANSACTION_DEAL_UPDATE) return;

      ulong order_ticket = trans.order;
      ulong deal_id = trans.deal;
      double deal_volume = trans.volume;

      if(order_ticket == 0 && result.order > 0) order_ticket = (ulong)result.order;
      if(order_ticket == 0 && deal_id > 0) order_ticket = (ulong)deal_id;

      int idx = FindRequestIndexByTicket(order_ticket);
      if(idx == -1)
      {
         g_trace.Log(TRACE_DEBUG, "EXEC", StringFormat("HandleTradeTransaction: no pending request for order=%llu deal=%llu vol=%.4f", order_ticket, deal_id, deal_volume));
         return;
      }

      double filled_inc = 0.0;
      if(deal_volume > 0.0) filled_inc = deal_volume;
      else if(result.volume > 0.0) filled_inc = result.volume;
      else
      {
         g_trace.Log(TRACE_DEBUG, "EXEC", "HandleTradeTransaction: no volume info");
         return;
      }

      m_requests[idx].filled += filled_inc;
      m_requests[idx].ts = TimeCurrent();

      double requested = m_requests[idx].requested;
      double filled = m_requests[idx].filled;

      // Completed
      if(filled >= requested - 1e-9)
      {
         m_requests[idx].status = REQ_FILLED;
         g_trace.Log(TRACE_INFO, "EXEC", StringFormat("Request completed: ticket=%llu requested=%.4f filled=%.4f run=%s hash=%s",
                       m_requests[idx].ticket, requested, filled, m_requests[idx].run_id, m_requests[idx].trace_hash));
         RemoveRequestByIndex(idx);
         return;
      }

      // Partial fill
      if(filled < requested)
      {
         double remaining = requested - filled;
         g_trace.Log(TRACE_WARNING, "EXEC", StringFormat("Partial fill observed ticket=%llu filled=%.4f remaining=%.4f retries=%d run=%s hash=%s",
                       m_requests[idx].ticket, filled, remaining, m_requests[idx].retries, m_requests[idx].run_id, m_requests[idx].trace_hash));
         if(m_requests[idx].retries < m_max_retries)
         {
            m_requests[idx].retries++;
            RetryPartialByIndex(idx, remaining);
         }
         else
         {
            g_trace.Log(TRACE_CRITICAL, "EXEC", StringFormat("Partial retries exhausted ticket=%llu remaining=%.4f run=%s hash=%s",
                         m_requests[idx].ticket, remaining, m_requests[idx].run_id, m_requests[idx].trace_hash));
            CancelRemainingByIndex(idx);
            g_trace.Log(TRACE_ALERT, "EXEC_PARTIAL_FAILED", StringFormat("{\"ticket\":%llu,\"remaining\":%.4f,\"run\":\"%s\",\"trace\":\"%s\"}",
                         m_requests[idx].ticket, remaining, m_requests[idx].run_id, m_requests[idx].trace_hash));
         }
         SavePendingRequestsToState();
         return;
      }

      // Overfill
      if(filled > requested + 1e-9)
      {
         double excess = filled - requested;
         g_trace.Log(TRACE_WARNING, "EXEC", StringFormat("Overfill detected ticket=%llu requested=%.4f filled=%.4f excess=%.4f run=%s hash=%s",
                       m_requests[idx].ticket, requested, filled, excess, m_requests[idx].run_id, m_requests[idx].trace_hash));
         m_requests[idx].status = REQ_OVERFILLED;
         ReconcileOverfillByIndex(idx, excess);
         RemoveRequestByIndex(idx);
         return;
      }
   }

   // RetryPartial: attempt to send a new immediate market order for remaining (uses stored side)
   void RetryPartialByIndex(int idx, double remaining)
   {
      if(idx < 0 || idx >= ArraySize(m_requests)) return;
      TradeRequest &r = m_requests[idx];

      // session check
      if(!g_session_manager.IsTradingSessionAllowed(r.symbol))
      {
         g_trace.Log(TRACE_WARNING, "EXEC", "RetryPartial blocked by SessionManager for " + r.symbol);
         return;
      }

      // risk check
      if(!g_risk_manager.CheckDrawdown())
      {
         g_trace.Log(TRACE_WARNING, "EXEC", "RetryPartial blocked by RiskManager for " + r.symbol);
         return;
      }

      // spread check
      if(!g_spread_monitor.IsAllowed(r.symbol))
      {
         g_trace.Log(TRACE_WARNING, "EXEC", "RetryPartial blocked by SpreadMonitor for " + r.symbol);
         return;
      }

      // Check if trade context is busy and wait with backoff
      int busy_retries = 0;
      m_backoff.Reset();
      while(IsTradeContextBusy() && busy_retries < m_max_retries)
      {
         g_trace.Log(TRACE_WARNING, "EXEC", StringFormat("RetryPartial: TradeContextBusy, waiting... retry=%d", busy_retries + 1));
         m_backoff.Wait();
         busy_retries++;
      }
      if(IsTradeContextBusy())
      {
         g_trace.Log(TRACE_WARNING, "EXEC", "RetryPartial: TradeContext still busy after max retries, skipping retry");
         return;
      }

      MqlTradeRequest req; MqlTradeResult res; ZeroMemory(req); ZeroMemory(res);
      req.action = TRADE_ACTION_DEAL;
      req.symbol = r.symbol;
      req.volume = remaining;
      req.deviation = m_deviation;
      req.type_filling = ORDER_FILLING_IOC;
      req.type = (r.side == SIDE_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;

      // Put deterministic correlation in comment for broker-side traceability
      string comment = StringFormat("run=%s req=%llu", m_run_id, r.request_id);
      StringConcatenate(req.comment, comment);

      bool sent = m_trade.OrderSend(req, res);
      if(sent)
      {
         double filled = (res.volume > 0.0) ? res.volume : req.volume;
         g_trace.Log(TRACE_INFO, "EXEC", StringFormat("RetryPartial OrderSend sent: ticket_for=%llu remaining=%.4f filled=%.4f",
                       r.ticket, remaining, filled));
         r.filled += filled;
         if(r.filled >= r.requested - 1e-9) { r.status = REQ_FILLED; RemoveRequestByIndex(idx); }
         else SavePendingRequestsToState();
      }
      else
      {
         g_trace.Log(TRACE_WARNING, "EXEC", StringFormat("RetryPartial OrderSend failed retcode=%d", res.retcode));
      }
   }

   void CancelRemainingByIndex(int idx)
   {
      if(idx < 0 || idx >= ArraySize(m_requests)) return;
      TradeRequest &r = m_requests[idx];
      r.status = REQ_CANCELED;
      g_trace.Log(TRACE_INFO, "EXEC", StringFormat("CancelRemaining: ticket=%llu remaining=%.4f run=%s hash=%s",
                    r.ticket, r.requested - r.filled, r.run_id, r.trace_hash));
      RemoveRequestByIndex(idx);
   }

   void ReconcileOverfillByIndex(int idx, double excess)
   {
      if(idx < 0 || idx >= ArraySize(m_requests)) return;
      TradeRequest &r = m_requests[idx];
      g_trace.Log(TRACE_WARNING, "EXEC", StringFormat("ReconcileOverfill: ticket=%llu excess=%.4f run=%s hash=%s",
                   r.ticket, excess, r.run_id, r.trace_hash));
      // No automatic close by default
   }

   void CheckPendingTimeouts()
   {
      datetime now = TimeCurrent();
      int i = 0;
      while(i < ArraySize(m_requests))
      {
         TradeRequest r = m_requests[i];
         if((int)(now - r.ts) > m_pending_timeout_seconds)
         {
            if(r.retries < m_max_retries)
            {
               m_requests[i].retries++;
               RetryPartialByIndex(i, r.requested - r.filled);
               i = 0; continue;
            }
            else
            {
               CancelRemainingByIndex(i);
               continue;
            }
         }
         i++;
      }
      SavePendingRequestsToState();
   }

   int PendingCount() { return ArraySize(m_requests); }
   bool GetPendingByIndex(int idx, TradeRequest &out) { if(idx < 0 || idx >= ArraySize(m_requests)) return false; out = m_requests[idx]; return true; }

   // ============================================================
   // Execute: main trade entry point. Validates session, spread, risk, computes lot, sends order and tracks expected volume.
   // Returns ExecutionResult describing success, ticket, lot_size and error messages.
   // ============================================================
   ExecutionResult Execute(const string symbol, const TradingSignal &signal)
   {
      ExecutionResult out;
      if(!signal.valid) { out.error_msg = "Invalid trading signal"; return out; }

      // INMUTABLE: Validar s√≠mbolo XAUUSD exclusivamente
      if(!ImmutableCore::ValidateSymbol(symbol))
      {
         out.error_msg = "Symbol validation failed: Only " + ImmutableCore::GetAllowedSymbol() + " allowed";
         g_trace.Log(TRACE_ERROR, "EXEC", out.error_msg);
         return out;
      }

      if(TimeCurrent() < m_breaker_end) { out.error_msg = "Execution breaker active"; return out; }

      // HealthMonitor governor check - blocks unhealthy trades
      #ifdef HEALTH_MONITOR_MQH
         if(g_health_monitor != NULL && !g_health_monitor->IsTradingAllowed(symbol))
         {
            out.error_msg = "HealthMonitor blocked execution (drawdown/kill_switch/breakers)";
            g_trace.Log(TRACE_WARNING, "EXEC", "Execute blocked by HealthMonitor for " + symbol);
            return out;
         }
      #endif

      if(!g_session_manager.IsTradingSessionAllowed(symbol)) { out.error_msg = "Trading session not allowed"; return out; }

      if(!RefreshRates(symbol)) { out.error_msg = "Failed to refresh rates"; return out; }

      if(!g_spread_monitor.IsAllowed(symbol)) { out.error_msg = "Spread check failed"; return out; }

      if(!g_risk_manager.CheckDrawdown()) { out.error_msg = "Drawdown check failed"; return out; }

      double lot = g_risk_manager.CalculateLot(symbol, signal.entry_price, signal.stop_loss);
      if(lot <= 0.0) { out.error_msg = "Calculated lot <= 0"; return out; }

      MqlTradeRequest req; MqlTradeResult res; ZeroMemory(req); ZeroMemory(res);
      req.action = TRADE_ACTION_DEAL;
      req.symbol = symbol;
      req.volume = lot;
      req.deviation = m_deviation;
      req.type_filling = ORDER_FILLING_IOC;
      req.type = signal.is_long ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;

      // generate client request id, put in comment for broker-side traceability
      ulong client_id = GenerateRequestId();
      string comment = StringFormat("run=%s client=%llu", m_run_id, client_id);
      StringConcatenate(req.comment, comment);

      int attempts = 0; m_backoff.Reset(); double remaining = lot;
      while(attempts <= m_max_retries && remaining > 0.0)
      {
         if(!g_risk_manager.CheckDrawdown()) { out.error_msg = "RiskManager blocked execution (drawdown/kill-switch)"; return out; }

         // Check if trade context is busy and wait with backoff
         int busy_retries = 0;
         while(IsTradeContextBusy() && busy_retries < m_max_retries)
         {
            g_trace.Log(TRACE_WARNING, "EXEC", StringFormat("TradeContextBusy, waiting... retry=%d", busy_retries + 1));
            m_backoff.Wait();
            busy_retries++;
         }
         if(IsTradeContextBusy())
         {
            out.error_msg = "TradeContext busy after max retries";
            g_trace.Log(TRACE_WARNING, "EXEC", "TradeContext still busy after max retries, canceling order");
            return out;
         }

         ZeroMemory(res);
         req.volume = remaining;

         bool sent = m_trade.OrderSend(req, res);
         attempts++;

         if(sent)
         {
            double filled = (res.volume > 0.0) ? res.volume : req.volume;
            ulong correl = 0;
            if(res.order > 0) correl = (ulong)res.order;
            else if(res.deal > 0) correl = (ulong)res.deal;
            ulong ticket_for_tracking = (correl != 0) ? correl : (ulong)GenerateRequestId();

            // add pending request: include side and run_id
            TradeSide side = signal.is_long ? SIDE_BUY : SIDE_SELL;
            AddPendingRequest(ticket_for_tracking, symbol, lot, side);

            out.success = true;
            out.ticket = ticket_for_tracking;
            out.lot_size = lot;
            out.request_id = client_id;

            g_trace.Log(TRACE_INFO, "EXEC", StringFormat("OrderSend success sym=%s ticket=%llu requested=%.4f filled=%.4f client=%llu run=%s",
                        symbol, ticket_for_tracking, lot, filled, client_id, m_run_id));
            return out;
         }
         else
         {
            int code = res.retcode; string desc = IntegerToString(code);
            #ifdef TRADE_RETCODE_DESCRIPTION_AVAILABLE
               desc = m_trade.ResultRetcodeDescription(code);
            #endif
            g_trace.Log(TRACE_WARNING, "EXEC", StringFormat("OrderSend failed retcode=%d desc=%s attempt=%d", code, desc, attempts));

            bool retryable = false;
            #ifdef TRADE_RETCODE_REQUOTE
               if(code == TRADE_RETCODE_REQUOTE) retryable = true;
            #endif
            #ifdef TRADE_RETCODE_CONTEXT_BUSY
               if(code == TRADE_RETCODE_CONTEXT_BUSY) retryable = true;
            #endif
            #ifdef TRADE_RETCODE_PRICE_CHANGED
               if(code == TRADE_RETCODE_PRICE_CHANGED) retryable = true;
            #endif

            if(retryable && attempts <= m_max_retries)
            {
               long delay = (long)m_backoff.GetNextDelay();
               Sleep((int)delay);
               continue;
            }
            else
            {
               out.success = false;
               out.error_msg = StringFormat("OrderSend failed code=%d desc=%s", code, desc);
               m_breaker_end = TimeCurrent() + 300; // 5 minutes
               g_trace.Log(TRACE_CRITICAL, "EXEC", "Max retries/irrecoverable error - breaker set for 5min");
               return out;
            }
         }
      } // end loop

      out.success = false;
      if(StringLen(out.error_msg) == 0) out.error_msg = "Execution loop ended without fill";
      return out;
   }

private:
   bool RefreshRates(const string symbol)
   {
      MqlTick tick;
      if(SymbolInfoTick(symbol, tick)) return true;
      g_trace.Log(TRACE_WARNING, "EXEC", "RefreshRates failed for " + symbol);
      return false;
   }
};

extern ExecutionEngine g_execution_engine;

#endif // EXECUTION_ENGINE_MQH
